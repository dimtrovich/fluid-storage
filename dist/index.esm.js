class e{constructor(e){this.prefix=e}getPrefix(){return this.prefix}normalizeKey(e){return this.prefix+"."+e.replace(new RegExp("^"+this.prefix+"\\."),"")}}class t extends e{get(e){return this.getAllCookies()[this.normalizeKey(e)]||null}set(e,t,r){const s=this.normalizeKey(e);let n="";if(r&&r>0){const e=Date.now()+60*r*1e3;n="; expires="+new Date(e).toUTCString()}document.cookie=`${s}=${encodeURIComponent(t)}${n}; path=/`}remove(e){const t=this.normalizeKey(e);document.cookie=`${t}=; path=/; expires=Thu, 01 Jan 1970 00:00:00 UTC`}clear(){const e=this.getAllCookies(),t=new RegExp("^"+this.prefix+"\\.");for(const r in e)t.test(r)&&this.remove(r.replace(this.prefix+".",""))}getAll(){const e=this.getAllCookies(),t={},r=new RegExp("^"+this.prefix+"\\.");for(const s in e)r.test(s)&&(t[s]=e[s]);return t}getAllCookies(){const e=document.cookie.split(";"),t={};return e.forEach(e=>{const r=e.split("=");if(r.length>=2){const e=r[0].trim(),s=decodeURIComponent(r.slice(1).join("="));t[e]=s}}),t}}class r extends e{get(e){return window.localStorage.getItem(this.normalizeKey(e))}set(e,t,r){window.localStorage.setItem(this.normalizeKey(e),t)}remove(e){window.localStorage.removeItem(this.normalizeKey(e))}clear(){const e=new RegExp("^"+this.prefix+"\\.");for(let t=0;t<window.localStorage.length;t++){const r=window.localStorage.key(t);r&&e.test(r)&&window.localStorage.removeItem(r)}}getAll(){const e={},t=new RegExp("^"+this.prefix+"\\.");for(let r=0;r<window.localStorage.length;r++){const s=window.localStorage.key(r);s&&t.test(s)&&(e[s]=window.localStorage.getItem(s))}return e}}class s extends e{get(e){return window.sessionStorage.getItem(this.normalizeKey(e))}set(e,t,r){window.sessionStorage.setItem(this.normalizeKey(e),t)}remove(e){window.sessionStorage.removeItem(this.normalizeKey(e))}clear(){const e=new RegExp("^"+this.prefix+"\\.");for(let t=0;t<window.sessionStorage.length;t++){const r=window.sessionStorage.key(t);r&&e.test(r)&&window.sessionStorage.removeItem(r)}}getAll(){const e={},t=new RegExp("^"+this.prefix+"\\.");for(let r=0;r<window.sessionStorage.length;r++){const s=window.sessionStorage.key(r);s&&t.test(s)&&(e[s]=window.sessionStorage.getItem(s))}return e}}class n{constructor(e,t){this.adapter=e,this.defaultExpire=t}get(e){if(Array.isArray(e))return this.many(e);const t=this.adapter.get(e);if(this.empty(t))return null;try{const r=JSON.parse(t),s=r.expire||0;return s>0&&Date.now()>=s?(this.remove(e),null):r.value||r}catch(e){return null}}many(e){const t={};for(const r of e)t[r]=this.get(r);return t}set(e,t,r){if("object"==typeof e&&!Array.isArray(e))return this.setMany(e,t);const s=void 0!==r?r:this.defaultExpire,n=!isNaN(Number(s))&&isFinite(Number(s))?Number(s):0,i=JSON.parse(JSON.stringify(t));let o=0;n>0&&(o=Date.now()+60*n*1e3);const l={value:i,expire:o};return this.adapter.set(e,JSON.stringify(l),n),this}setMany(e,t){for(const[r,s]of Object.entries(e))this.set(r,s,t);return this}remove(...e){for(const t of e)this.adapter.remove(t);return this}clear(){return this.adapter.clear(),this}getAll(){const e=this.adapter.getAll(),t={};for(const[r,s]of Object.entries(e))try{const e=JSON.parse(s);if(e.expire&&Date.now()>=e.expire){this.remove(r.replace(this.adapter.getPrefix()+".",""));continue}t[r.replace(this.adapter.getPrefix()+".","")]=e.value||e}catch(e){}return t}expire(e,t){const r=this.adapter.get(e);if(this.empty(r))return this;try{const s=JSON.parse(r);let n=0;t>0&&(n=Date.now()+60*t*1e3);const i={value:s.value||s,expire:n};this.adapter.set(e,JSON.stringify(i),t)}catch(e){}return this}getExpire(e){const t=this.adapter.get(e);if(this.empty(t))return null;try{const e=JSON.parse(t).expire||0;if(0===e)return 1/0;const r=e-Date.now();return r>0?Math.ceil(r/1e3/60):0}catch(e){return null}}empty(e){return null==e||("string"==typeof e&&""===e||(!(!Array.isArray(e)||0!==e.length)||"object"==typeof e&&0===Object.keys(e).length))}}class i extends n{increment(e,t=1){const r=this.get(e)||0;if("number"!=typeof r)throw new Error(`Cannot increment non-numeric value for key: ${e}`);const s=r+t;return this.set(e,s),s}decrement(e,t=1){return this.increment(e,-t)}remember(e,t,r){const s=this.get(e);if(null!==s)return s;const n="function"==typeof t?t():t;return this.set(e,n,r),n}pull(e){const t=this.get(e);return this.remove(e),t}has(e){return null!==this.get(e)}put(e,t,r){return this.set(e,t,r)}add(e,t,r){return!this.has(e)&&(this.set(e,t,r),!0)}forever(e,t){return this.set(e,t,0)}forget(...e){return this.remove(...e)}flush(){return this.clear()}exists(e){return this.has(e)}missing(e){return!this.has(e)}except(...e){const t=this.getAll();for(const r of e)delete t[r];return t}hasAny(e){return e.some(e=>this.has(e))}hasAll(e){return e.every(e=>this.has(e))}missingAny(e){return e.some(e=>!this.has(e))}missingAll(e){return e.every(e=>!this.has(e))}only(...e){const t={};for(const r of e){const e=this.get(r);null!==e&&(t[r]=e)}return t}first(e){for(const t of e){const e=this.get(t);if(null!==e)return e}return null}last(e){for(let t=e.length-1;t>=0;t--){const r=this.get(e[t]);if(null!==r)return r}return null}random(e=1){const t=this.getAll(),r=Object.keys(t);if(0===r.length)return 1===e?null:[];if(1===e){return t[r[Math.floor(Math.random()*r.length)]]}const s=[],n=[...r].sort(()=>.5-Math.random());for(let i=0;i<Math.min(e,r.length);i++)s.push(t[n[i]]);return s}isEmpty(e){return this.empty(this.get(e))}isNotEmpty(e){return!this.isEmpty(e)}count(){return Object.keys(this.getAll()).length}keys(){return Object.keys(this.getAll())}values(){return Object.values(this.getAll())}keyExists(e){return this.keys().includes(e)}tap(e,t){const r=this.get(e);if(null!==r){const s=t(r);this.set(e,s)}return this}times(e,t,r){for(let s=0;s<e;s++)this.set(`item_${s}`,t(s),r);return this}wrap(e,t,r){const s=t(this.get(e));return this.set(e,s,r),s}expireMany(e,t){for(const r of e)this.expire(r,t);return this}extend(e,t){const r=this.getExpire(e);if(null===r)return this;if(r===1/0)return this;const s=r+t;return this.expire(e,s)}reduce(e,t){const r=this.getExpire(e);if(null===r)return this;if(r===1/0)return this.expire(e,t);const s=Math.max(0,r-t);return this.expire(e,s)}}
/**!
 * Fluid Storage v1.0.0 (https://github.com/dimtrovich/fluid-storage)
 * Copyright 2025 Dimtrov Lab's | Dimitri Sitchet Tomkeu
 * Licensed under MIT (https://opensource.org/licences/mit)
 *
 * @author Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>
 * @copyright Dimtrov Lab's | Dimitri Sitchet Tomkeu
 * @description Une interface de stockage structuré de données côté client simple et rapide
 * @version 1.0.0
 * @licence MIT
 */function o(e,n,o){let l;const a=e||"fs",h=n||"localstorage";if("string"==typeof h)switch(h.toLowerCase()){case"localstorage":default:l=new r(a);break;case"sessionstorage":l=new s(a);break;case"cookie":l=new t(a)}else l=h;return new i(l,o)}"undefined"!=typeof window&&(window.fluidStorage={init:o});var l={init:o};export{e as BaseAdapter,t as CookieStorageAdapter,r as LocalStorageAdapter,s as SessionStorageAdapter,l as default,o as init};
